<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>my-first-blog | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#React Component 翻译  原文地址：https://reactjs.org/docs/react-component.html  组件(Component)可以使你将UI分割成一个个独立的、可重用的代码块，并且每一块都是相互独立的。React.Component 是由 React 提供的。">
<meta property="og:type" content="article">
<meta property="og:title" content="my-first-blog">
<meta property="og:url" content="http://yoursite.com/2018/02/13/my-first-blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#React Component 翻译  原文地址：https://reactjs.org/docs/react-component.html  组件(Component)可以使你将UI分割成一个个独立的、可重用的代码块，并且每一块都是相互独立的。React.Component 是由 React 提供的。">
<meta property="og:updated_time" content="2018-02-13T06:39:39.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="my-first-blog">
<meta name="twitter:description" content="#React Component 翻译  原文地址：https://reactjs.org/docs/react-component.html  组件(Component)可以使你将UI分割成一个个独立的、可重用的代码块，并且每一块都是相互独立的。React.Component 是由 React 提供的。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-my-first-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/13/my-first-blog/" class="article-date">
  <time datetime="2018-02-13T06:37:10.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      my-first-blog
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#React Component 翻译</p>
<blockquote>
<p>原文地址：<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">https://reactjs.org/docs/react-component.html</a></p>
</blockquote>
<p>组件(<code>Component</code>)可以使你将UI分割成一个个独立的、可重用的代码块，并且每一块都是相互独立的。<code>React.Component</code> 是由 <code>React</code> 提供的。</p>
<a id="more"></a>
<p>###概览(OverView)</p>
<p><code>React.Component</code> 是一个抽象基类，所以直接引用 <code>React.Component</code> 是没有意义的。您应该继承它，并且至少定义<code>render()</code>方法。</p>
<p>通常，你可以像定义一个普通的<code>JavaScript</code>类一样，定义一个 React 组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line">render() &#123;</span><br><span class="line">return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您还没有使用ES6，您可以使用<code>create-react-class</code>模块替代：<a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener"><code>Using React without ES6</code> </a></p>
<p>请注意，<strong>我们不推荐您自己创建基础组件类</strong>。在 React 中，代码复用主要是通过 Composition 实现的，而不是继承 (inheritance) 的方式。点击该链接中的<a href="https://reactjs.org/docs/composition-vs-inheritance.html" target="_blank" rel="noopener">使用情形</a>感受下如何使用 Composition 。</p>
<p>###组件的生命周期(The Component Lifecycle)</p>
<p>每个组件都有几个“生命周期方法”，你可以在进程中的特定时机复写这些方法。具有 <strong>will</strong> 前缀的方法在某些事件发生前调用，而具有 <strong>did</strong> 前缀的方法在某些事件发生后调用.</p>
<p>####Mounting 加载方法</p>
<p>这些方法会在组件实例创建后并加载入DOM中时调用。</p>
<ul>
<li><code>constructor()</code></li>
<li><code>componentWillMount()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<p>####Updating 更新方法</p>
<p>当props 或者 state 变化时，会调用更新方法。这些方法在组件被重新渲染时调用。</p>
<ul>
<li><code>componentWillReceiveProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>componentWillUpdate()</code></li>
<li><code>render()</code></li>
<li><code>componentDidUpdate()</code></li>
</ul>
<p>####Unmounting </p>
<p>该方法在组件从DOM中移除时被调用。</p>
<p>####Error Handling 错误捕捉</p>
<p>在一个生命周期方法中，或者在任何一个子组件的构造方法中，当组件渲染时发生错误时，该方法会被调用。</p>
<ul>
<li><code>componentDidCatch()</code></li>
</ul>
<p>###其余API(Other APIs)</p>
<p>每个组件也提供一些其他的API：</p>
<ul>
<li><code>setState()</code></li>
<li><code>forceUpdate()</code></li>
</ul>
<p>###类属性(Class Properties)</p>
<ul>
<li><code>defaultProps</code></li>
<li><code>displayName</code></li>
</ul>
<p>###实例属性(Instance Properties)</p>
<ul>
<li><code>props</code></li>
<li><code>state</code></li>
</ul>
<p>–</p>
<p>###引用(Reference)</p>
<p>####<strong>render()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render()</span><br></pre></td></tr></table></figure></p>
<p>render() 方法是必须的。</p>
<p>当调用该方法时，它将会检验 this.props 和 this.state，并会返回如下类型之一：</p>
<ul>
<li><strong>React elements.</strong> 通常是由JSX创建的。一个元素既可以是一个本地DOM组件的表示(a representation of a native DOM component)(<code>&lt;div /&gt;</code>)，也可以是一个用户定义的组件(user-defined composite component)(<code>&lt;MyComponent /&gt;</code>)。</li>
<li><strong>String and numbers.</strong> 这些类型会像在DOM中那样作为文本节点渲染。</li>
<li><strong>Portals.</strong> 通过 <code>ReactDOM.createPortal</code> 创建。</li>
<li><strong>null.</strong> 不进行渲染。</li>
<li><strong>Booleans.</strong> 不进行渲染。（通常是这样的形式：<code>return test &amp;&amp; &lt;Child /&gt;</code>，其中 <code>test</code> 是一个布尔值。）</li>
</ul>
<p>当返回 <code>null</code> 或者 <code>false</code>，<code>ReactDOM.findDOMNode(this)</code> 将会返回 null。</p>
<p>render() 方法应该是纯粹的(pure)，这意味着它不会改变组件的状态，在每次调用它时，它返回的是同样的结果，并且它不直接与浏览器进行交互。如果你想与浏览器进行交互，将交互的工作放在<code>componentDidMount()</code>方法中，或者其他的生命周期方法里。保持render()方法干净纯粹能够使组件更容易理解。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>render()方法在 <code>shouldComponentUpdate()</code>方法返回false时，不会被调用。</p>
</blockquote>
<p>#####Fragments(碎片)</p>
<p>你也可以使用数组从render()方法中返回多个条目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">return [</span><br><span class="line">&lt;li key=&quot;A&quot;&gt;First item&lt;/li&gt;,</span><br><span class="line">&lt;li key=&quot;B&quot;&gt;Second item&lt;/li&gt;,</span><br><span class="line">&lt;li key=&quot;C&quot;&gt;Third item&lt;/li&gt;,</span><br><span class="line">];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>不要忘记 为碎片中的 元素添加上 键名，以避免警告。(Don’t forget to add keys to elements in a fragment to avoid the key warning.)</p>
</blockquote>
<p>从 React 16.0.2 版本后，还可以使用 <code>fragments</code>来完成上述内容，这时就不需要为静态条目指定键名了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;React.Fragment&gt;</span><br><span class="line">&lt;li&gt;First item&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Second item&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Third item&lt;/li&gt;</span><br><span class="line">&lt;/React.Fragment&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–</p>
<p>####<strong>constructor()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor(props)</span><br></pre></td></tr></table></figure></p>
<p>一个 React 组件的构造方法在它被加载之前调用。当实现一个React.Component 子类的构造方法时，你应该在所有代码前首先调用<code>super(props)</code>方法。否则，this.props 属性将会在构造方法中不被定义(undefined)，从而导致问题。</p>
<p>避免在构造方法中引入任何副作用或者订阅。要使用，请在<code>componentDidMount()</code>方法中使用。</p>
<p>在构造方法中 初始化状态 是最合适的。只需要将对象赋值给 <code>this.state</code>；请不要尝试在构造方法中调用 <code>setState()</code>方法。构造方法也通常用来绑定事件处理与类实例。</p>
<p>如果不初始化状态并且不绑定方法，那么就不需要在 React 组件中实现构造方法。</p>
<p>少数情况下，可以基于props来初始化状态。这会有效地通过初始属性来 “forks” props 并设置状态。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">super(props);</span><br><span class="line">this.state = &#123;</span><br><span class="line">color: props.initialColor</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这种形式：状态值(state)不会随着任何属性值(props)的更新而更新。若想要同步props和state，可以使用 <a href="https://reactjs.org/docs/lifting-state-up.html" target="_blank" rel="noopener">lift the state up</a>。</p>
<p>如果你使用这种形式来”fork” props，你可能也想要实现 <code>componentWillReceiveProps(nextProps)</code> 来保证状态值是更新并与props保持一致的。但是通常，lifting state up 更简单，并且可能问题更少。</p>
<p>–</p>
<p>####<strong>componentWillMount()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount()</span><br></pre></td></tr></table></figure></p>
<p><code>componentWillMount()</code> 方法在组件被加载之前会被立即调用。该方法在 <code>render()</code> 之前调用，因此在该方法中同步调用 <code>setState()</code> 方法并不会触发额外的渲染。通常，我们推荐使用<br><code>constructor()</code> 构造方法来初始化状态。</p>
<p>避免在构造方法中引入任何副作用或者订阅。要使用，请在<code>componentDidMount()</code>方法中使用。</p>
<p>这是在服务器渲染上调用的唯一的生命周期方法。</p>
<p>–</p>
<p>####<strong>componentDidMount()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()</span><br></pre></td></tr></table></figure></p>
<p>componentDidMount()方法在组件被加载后立即调用。需要DOM节点的初始化需要放在这里。如果你需要从远端读取数据，最好把初始化网络请求的方法放在这里。</p>
<p>这个方法适合放置任何的订阅。如果您要这么做，不要忘记在<code>componentWillUnmount()</code>方法中解注册。</p>
<p>在该方法中调用 <code>setState()</code> 方法将会触发额外的渲染，但是这会发生在浏览器更新屏幕内容之前。这保证了即使这种情况下 <code>render()</code> 方法会被调用两次，用户也不会看到中断的状态。使用这种形式需要小心，因为它通常会引发性能问题。但是，当需要在渲染依赖于其大小或位置的东西之前测量DOM节点时，可能需要类似于模态和工具提示的情况。( It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.)</p>
<p>–</p>
<p>####<strong>componentWillReceiveProps()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps)</span><br></pre></td></tr></table></figure></p>
<p><code>componentWillReceiveProps()</code> 方法在加载的组件接收到新的属性前被激发。如果你需要在属性值变化时，更新状态值（比如，重置属性操作），你可以比较 <code>this.props</code> 与 <code>nextProps</code> ，然后在该方法中使用 <code>this.setState()</code> 来执行状态转变。</p>
<p>注意，即使属性值未发生变化，React 也可能会调用该方法。所以如果你仅仅想处理值变化的情形，请确保在执行操作前比较当前值与新值(next values)。当父组件引起你的组件重新渲染时，有可能会出现这种情况。</p>
<p>React 并不会在具有初始属性值的<code>mounting</code>过程中调用<code>componentWillReceiveProps</code>。它仅会在某些组件的属性值可能发生变化时被调用。调用<code>this.setState()</code>通常不会触发 <code>componentWillReceiveProps</code>。</p>
<p>–</p>
<p>####<strong>shouldComponentUpdate()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps,nextState)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>shouldComponentUpdate()</code>来通知React一个组件的输出是否不受当前状态值或者属性值的变化影响。默认的行为是，每当状态值变化时，都重新渲染，并且大多数情况下，你应该依赖这一默认的行为。</p>
<p>当收到新的属性或状态时，<code>shouldComponentUpdate()</code>在渲染前被调用。默认值是<code>true</code>。在首次渲染或者使用<code>forceUpdate()</code>方法时，该方法不会被调用。</p>
<p>如果返回<code>false</code>，并不会阻止子组件在他们的状态变化时重新渲染。</p>
<p>现在，如果<code>shouldComponentUpdate()</code>返回<code>false</code>，那么<code>componentWillUpdate()</code>、<code>render()</code>、<code>componentDidUpdate()</code>方法将不会被调用。请注意，将来React可能会将<code>shouldComponentUpdate()</code>作为提示而不是严格的指令，并且返回<code>false</code>仍可能导致组件的重新渲染。</p>
<p>如果确定特定组件在分析后很慢，则可以将其更改为从<code>React.PureComponent</code>继承，<code>React.PureComponent</code>实现了与浅层prop(shallow prop)和state比较(state comparison)的<code>shouldComponentUpdate()</code>。如果你很有信心自己实现，你需要比较 <code>this.props</code>和<code>nextProps</code>、<code>this.state</code>和<code>nextState</code>，然后返回<code>false</code>来告诉 React 更新可以跳过。</p>
<p>我们不推荐在<code>shouldComponentUpdate()</code>方法中执行深层的相等检查(deep equality checks)或者使用<code>JSON.stringify()</code>，因为这会非常的低效，损害性能。</p>
<p>–</p>
<p>####<strong>componentWillUpdate()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(nextProps,nextState)</span><br></pre></td></tr></table></figure></p>
<p>当收到新的属性或者状态时，<code>componentWillUpdate()</code>会立即在渲染前被调用。在更新发生之前，使用该方法来为其做准备。在首次渲染时，该方法不被调用。</p>
<p>注意，你不能在该方法中调用<code>setState()</code>方法；也不能在<code>componentWillUpdate()</code>返回值前做任何会触发React组件更新的操作（比如 dispatch a Redux action）。</p>
<p>如果你需要更新state来响应props的变化，使用<code>componentWillReceiveProps()</code>。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>如果<code>shouldComponentUpdate()</code>返回false，<code>componentWillUpdate()</code>方法将不被调用。</p>
</blockquote>
<p>–</p>
<p>####<strong>componentDidUpdate()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(prevProps,prevState)</span><br></pre></td></tr></table></figure></p>
<p>在更新发生后，<code>componentDidUpdate()</code>方法被立即调用。初始渲染时，该方法不会被调用。</p>
<p>在该方法中，当组件更新后，操作DOM。只要你将当前属性与之前属性比较后，该方法也适合放置网络请求（比如，如果属性没有变化，那么就不需要执行网络请求）。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>如果<code>shouldComponentUpdate()</code>返回false，<code>componentDidUpdate()</code>方法将不被调用。</p>
</blockquote>
<p>–</p>
<p>####<strong>componentWillUnmount()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount()</span><br></pre></td></tr></table></figure></p>
<p>在卸载和销毁组件之前会立即调用<code>componentWillUnmount()</code>。在该方法中执行任何必要的清除操作，比如取消定时器(invalidating timers)、取消网络请求、以及清除所有在<code>componentDidMount()</code>中创建的订阅者。</p>
<p>–</p>
<p>####<strong>componentDidCatch()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error,info)</span><br></pre></td></tr></table></figure></p>
<p>错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误，并显示备用UI而不是崩溃的组件树。错误边界在渲染，生命周期方法以及整个树下的构造函数中捕获错误。</p>
<p>如果一个类组件定义了这个生命周期方法，它将成为一个错误边界。调用它中的<code>setState()</code>可以让您捕获下面的树中未处理的JavaScript错误，并显示回退UI。只能使用错误边界从意外的异常中恢复; 不要试图将它们用于流程控制。</p>
<p>更多详情，参考 <strong><a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">Error Handling in React 16</a></strong></p>
<blockquote>
<p><strong>注意</strong></p>
<p>错误边界只会捕获树中下面的组件中的错误。 错误边界本身不能捕获错误。</p>
</blockquote>
<p>–</p>
<p>####<strong>setState()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(updater[, callback])</span><br></pre></td></tr></table></figure></p>
<p><code>setState()</code>方法将对组件状态的更改进行排队，并告诉React该组件及其子组件需要使用更新后的状态进行重新呈现。这是用来更新用户界面以响应事件处理程序和服务器响应的主要方法。</p>
<p>把<code>setState()</code>看作是一个请求，而不是一个立即的命令来更新组件。为了获得更好的感知性能，React可能会延迟它，然后一次更新几个组件。React不保证立即应用状态更改。</p>
<p><code>setState()</code>方法通常不会立即更新组件。它可能会批处理或推迟更新，直到更晚。这使得在调用<code>setState()</code>之后立即读取<code>this.state</code>是一个潜在的缺陷。相反，使用<code>componentDidUpdate</code>或<code>setState</code>回调<code>（setState（updater，callback））</code>，其中任何一个都能保证在组件被更新后触发。如果你需要依据之前的状态来设定当前状态，请阅读下面的<code>updater</code>参数。</p>
<p>通常，<code>setState()</code>方法会导致组件重新渲染，除非<code>shouldComponentUpdate()</code>方法返回<code>false</code>。如果正在使用可变对象，并且在<code>shouldComponentUpdate()</code>中不能实现条件呈现逻辑，只有当新状态与先前状态不同时调用<code>setState()</code>才能避免不必要的重新呈现。</p>
<p>第一个参数是一个<code>updater</code>函数，签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(prevState, props) =&gt; stateChange</span><br></pre></td></tr></table></figure>
<p>其中，<code>prevState</code>是先前状态的引用。它不应该直接变化。相反，应该通过建立一个基于prevState和props的输入的新对象来表示变化。例如，假设我们想通过props.step增加一个状态值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">return &#123;counter: prevState.counter + props.step&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>保证<code>updater</code>函数收到的<code>prevState</code>和<code>props</code>都是最新的。 <code>updater</code>的输出与<code>prevState</code>合并。(The output of the updater is shallowly merged with prevState.)</p>
<p><code>setState()</code>方法的第二个参数是一个回调函数（可选），它在<code>setState</code>完成后并且组件被重新渲染后，立即执行。通常，我们推荐在<code>componentDidUpdate()</code>方法中来实现该逻辑。</p>
<p>你可以选择向<code>setState()</code>方法的第一个参数中传入一个对象，而不是函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(stateChange[, callback])</span><br></pre></td></tr></table></figure>
<p>这会将<code>stateChange</code>融合到新状态中，比如调整购物车项目数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;quantity: 2&#125;)</span><br></pre></td></tr></table></figure>
<p>这种形式的<code>setState()</code>方法也是异步的，在一个循环中的多个调用也可能被打包起来一并执行。例如，如果你试图在一个循环中多次增加某个项目的数量，这将等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">previousState,</span><br><span class="line">&#123;quantity: state.quantity + 1&#125;,</span><br><span class="line">&#123;quantity: state.quantity + 1&#125;,</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在一个循环中，后续的调用将会复写先前调用的值，所以数量只会被增加一次。如果下一个状态依赖于前一状态，我们推荐使用<code>updater</code>函数形式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState) =&gt; &#123;</span><br><span class="line">return &#123;quantity: prevState.quantity + 1&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>更多详情，参考 <strong><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">State and Lifecycle guide</a></strong></p>
<p>–</p>
<p>####<strong>forceUpdate()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.forceUpdate(callback)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，当组件的状态或者属性变化时，组件会被重新渲染。如果你的<code>render()</code>方法依赖其他的一些数据，你可以通过调用<code>forceUpdate()</code>来告诉 React 组件需要重新渲染。</p>
<p>调用<code>forceUpdate()</code>将会调用组件的<code>render()</code>方法，而略过<code>shouldComponentUpdate()</code>方法。这将会触发子组件的正常生命周期方法，包括每个子组件的<code>shouldComponentUpdate()</code>方法。如果标记更改，React将只会更新DOM。</p>
<p>通常你应该尽量避免使用<code>forceUpdate()</code>，只能从<code>render()</code>中的<code>this.props</code>和<code>this.state</code>中读取。</p>
<p>–</p>
<p>###类属性(Class Properties)</p>
<p>####defaultProps</p>
<p>可以将<code>defaultProps</code>定义为组件类本身的属性，以设置该类的默认props。这用于未定义的props，但不适用于null props。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CustomButton extends React.Component &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomButton.defaultProps = &#123;</span><br><span class="line">color: &apos;blue&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果未提供<code>props.color</code>，那么它将会被设为默认值<code>&#39;blue&#39;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">return &lt;CustomButton /&gt; ; // props.color will be set to blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果<code>props.color</code>被设置为null，那么它将保持为null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">return &lt;CustomButton color=&#123;null&#125; /&gt; ; // props.color will remain null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–</p>
<p>####desplayName</p>
<p>displayName字符串用于调试消息。 通常，您不需要明确设置它，因为它是从定义组件的函数或类的名称推断出来的。 如果要为调试目的显示不同的名称，或者要创建高阶组件，则可能需要显式设置它，有关详细信息，请参阅 <strong><a href="https://reactjs.org/docs/higher-order-components.html#convention-wrap-the-display-name-for-easy-debugging" target="_blank" rel="noopener">Wrap the Display Name for Easy Debugging</a></strong> 。</p>
<p>–</p>
<p>###实例属性(Instance Properties)</p>
<p>####props</p>
<p>this.props包含由该组件的调用者定义的props。 请参阅<strong><a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Components and Props</a></strong>以了解props的介绍。</p>
<p>特别的，this.props.children是一个特殊的prop，通常由JSX表达式中的子标签定义，而不是标签本身。</p>
<p>####state</p>
<p>state包含特定于此组件的数据，可能随时间而改变。state是用户定义的，它应该是一个一般的JavaScript对象。</p>
<p>如果你不在<code>render()</code>中使用它，那么它不应在state中。例如，你可以把定时器的IDs直接放在实例中。</p>
<p>参阅 <strong><a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">State and Lifecycle</a></strong> 获取关于state的更多信息。</p>
<p>不要直接改变<code>this.state</code>，因为之后调用<code>setState()</code>可能会取代你之前所做的改变。将<code>this.state</code>看作是不可变的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/13/my-first-blog/" data-id="cjdla00n10001wyfygziii4x5" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/02/13/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/13/my-first-blog/">my-first-blog</a>
          </li>
        
          <li>
            <a href="/2018/02/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>